use std::time::{Duration, Instant};

use auth::{Scope, ScopeSet};

/// A container to hold Reddit-generated authentication secrets.
#[derive(Clone, Debug)]
pub struct AuthenticationSecrets {
    client_id: String,
    client_secret: Option<String>,
}

impl AuthenticationSecrets {
    /// Creates a new container that holds the provided secrets.
    ///
    /// # Examples
    ///
    /// ```
    /// use snoo::auth::AuthenticationSecrets;
    /// let secrets = AuthenticationSecrets::new("abc123", "xyz890");
    /// ```
    ///
    /// If a client_secret is not available for your application, `None` can be passed instead.
    ///
    /// ```
    /// use snoo::auth::AuthenticationSecrets;
    /// let secrets = AuthenticationSecrets::new("abc123", None);
    /// ```
    pub fn new<S, O>(client_id: S, client_secret: O) -> AuthenticationSecrets
    where
        S: Into<String>,
        O: Into<Option<S>>,
    {
        AuthenticationSecrets {
            client_id: client_id.into(),
            client_secret: client_secret.into().map(|value| value.into()),
        }
    }
}


/// The method used for authentication.
///
/// More information about the authorization and authentication process can be found in Reddit's
/// [OAuth 2 documentation] on GitHub.
///
/// [OAuth 2 documentation]: https://github.com/reddit/reddit/wiki/OAuth2
#[derive(Clone, Debug)]
pub enum AuthenticationMethod {
    /// Authenticate without a user context. For installed applications and other
    /// applications acting on behalf of one or more "logged out" users.
    ClientCredentials,
    /// Authenticate using an authorization code retrieved from Reddit.
    Code {
        /// The authorization code retrieved from Reddit.
        code: String,
        /// The same redirect URI that is registered with Reddit.
        redirect_uri: String,
        /// A set of [scopes] to request during authentication.
        ///
        /// [scopes]: enum.Scope.html
        scope: ScopeSet,
    },
    /// Authenticate without a user context. For web and script applications not acting on
    /// behalf of one or more users.
    ///
    /// A device ID is a string of 20-30 ASCII characters that is generated by your application and
    /// uniquely identifies the device and user. A random or pseudo-random value is acceptable, and
    /// should be reused.
    DeviceId(String),
    /// Authenticate using a refresh token.
    RefreshToken(String),
    /// Authenticate on behalf of a user with a username and password.
    UserCredentials {
        /// The user's password.
        password: String,
        /// The user's username.
        username: String,
        /// A set of [scopes] to request during authentication.
        ///
        /// [scopes]: enum.Scope.html
        scope: ScopeSet,
    },
}

#[derive(Clone, Debug, Deserialize)]
pub struct BearerToken {
    access_token: String,
    expires_in: Duration,
    refresh_token: Option<String>,
    scope: ScopeSet,
}

impl BearerToken {
    pub fn access_token(&self) -> &str {
        self.access_token.as_str()
    }

    pub fn expires_in(&self) -> Duration {
        self.expires_in
    }

    pub fn refresh_token(&self) -> Option<&str> {
        self.refresh_token.as_ref().map(String::as_ref)
    }

    pub fn scope(&self) -> &ScopeSet {
        &self.scope
    }

    pub fn is_expired(&self, since: Instant) -> bool {
        since.elapsed() >= self.expires_in
    }

    pub fn is_refreshable(&self) -> bool {
        self.refresh_token.is_some()
    }

    pub fn matches_scope(&self, scope: Scope) -> bool {
        scope == Scope::All || self.scope.contains(scope) || self.scope.contains(Scope::All)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn bearer_token_is_expired() {
        let token = BearerToken {
            access_token: "abc123".to_owned(),
            expires_in: Duration::from_secs(3600),
            refresh_token: None,
            scope: ScopeSet::new(),
        };
        let instant = Instant::now() - Duration::from_secs(3601);
        assert!(token.is_expired(instant))
    }

    #[test]
    fn bearer_token_is_not_expired() {
        let token = BearerToken {
            access_token: "abc123".to_owned(),
            expires_in: Duration::from_secs(3600),
            refresh_token: None,
            scope: ScopeSet::new(),
        };
        let instant = Instant::now();
        assert!(!token.is_expired(instant))
    }
}
