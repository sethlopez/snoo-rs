use std::sync::Arc;

use tokio_core::reactor::Handle;

use error::SnooBuilderError;
use net::HttpClient;
use reddit::auth::{AppSecrets, AuthFlow, Authenticator, AuthorizationUrlBuilder, BearerToken,
                   BearerTokenFuture, Scope, ScopeSet, SharedBearerTokenFuture};
use reddit::RedditClient;

/// The client with which to send requests to the Reddit API.
#[derive(Debug)]
pub struct Snoo {
    reddit_client: Arc<RedditClient>,
}

impl Snoo {
    fn new(reddit_client: RedditClient) -> Snoo {
        Snoo {
            reddit_client: Arc::new(reddit_client),
        }
    }

    /// Creates a builder which you can use to configure and build a `Snoo` client.
    pub fn builder() -> SnooBuilder {
        SnooBuilder::default()
    }

    /// Creates a builder which you can use to build an authorization URL.
    pub fn authorization_url_builder() -> AuthorizationUrlBuilder {
        AuthorizationUrlBuilder::default()
    }

    /// Returns a future that resolves to a [`BearerToken`].
    ///
    /// [`BearerToken`]: auth/struct.BearerToken.html
    ///
    /// This method should only be used to retrieve the bearer token. `Snoo` will automatically
    /// retrieve a bearer token on its own when making requests to Reddit.
    pub fn bearer_token(&self, force: bool) -> SharedBearerTokenFuture {
        self.reddit_client.bearer_token(force)
    }

    pub fn user<T>(&self, name: T)
    where
        T: Into<String>,
    {
        unimplemented!()
    }

    pub fn subreddit<T>(&self, name: T)
    where
        T: Into<String>,
    {
        unimplemented!()
    }

    pub fn submission<T>(&self, id: T)
    where
        T: Into<String>,
    {
        unimplemented!()
    }

    pub fn comment<T>(&self, id: T)
    where
        T: Into<String>,
    {
        unimplemented!()
    }

    pub fn message<T>(&self, id: T)
    where
        T: Into<String>,
    {
        unimplemented!()
    }
}

// TODO: Add options for refreshing the bearer token and rate-limiting requests
/// A builder, following the builder pattern, that can configure and build a [`Snoo`] client.
///
/// [`Snoo`]: struct.Snoo.html
///
/// # Required Settings
///
/// When building a [`Snoo`] client, you must provide your app secrets (client ID and secret) and a
/// custom user agent. Additionally, you will need to provide some authentication information;
/// Either a [bearer token], or a [code], [refresh token], or [username and password].
///
/// [`Snoo`]: struct.Snoo.html
/// [bearer token]: #method.bearer_token
/// [code]: #method.code_auth
/// [refresh token]: #method.refresh_token_auth
/// [username and password]: #method.password_auth
#[derive(Debug, Default)]
pub struct SnooBuilder {
    app_secrets: Option<AppSecrets>,
    auth_flow: Option<AuthFlow>,
    bearer_token: Option<BearerToken>,
    user_agent: Option<String>,
}

impl SnooBuilder {
    /// Sets the required client ID and client secret generated by Reddit for your app.
    ///
    /// Your app's client ID and client secret can be found in your [app preferences].
    ///
    /// [app preferences]: https://www.reddit.com/prefs/apps/
    pub fn app_secrets<T, U>(mut self, client_id: T, client_secret: U) -> Self
    where
        T: Into<String>,
        U: Into<Option<T>>,
    {
        let app_secrets = AppSecrets::new(client_id, client_secret);
        self.app_secrets = Some(app_secrets);
        self
    }

    /// Sets a bearer token to use for authentication.
    ///
    /// In some cases, such as [`Token`] authorization, you may already have a bearer token to use
    /// for authenticating a user. Setting a bearer token removes the requirement to also set a
    /// code, username and password, or refresh token to use for authentication.
    ///
    /// **Note:** If a code or refresh token is already set, setting a bearer token will cause them
    /// to be forgotten. If the bearer token includes a refresh token, the [`Snoo`] client will
    /// automatically retrieve a new token when necessary.
    ///
    /// [`Token`]: auth/enum.ResponseType.html#variant.Token
    /// [`Snoo`]: struct.Snoo.html
    pub fn bearer_token(mut self, bearer_token: BearerToken) -> Self {
        self.bearer_token = Some(bearer_token);
        self
    }

    /// Sets the information needed for code authentication.
    ///
    /// If a user used a [`Code`] URL to authorize your application, you will receive a special
    /// code, via a `code` query parameter appended to your redirect URI, that can be exchanged for
    /// a bearer token.
    ///
    /// [`Code`]: auth/enum.ResponseType.html#variant.Code
    ///
    /// In addition to the code, the redirect URI registered for your app and the same scopes used
    /// during authorization must also be used to obtain a bearer token.
    pub fn code_auth<T, U>(mut self, code: T, redirect_uri: T, scope: U) -> Self
    where
        T: Into<String>,
        U: IntoIterator<Item = Scope>,
    {
        let auth_flow = AuthFlow::Code {
            code: code.into(),
            redirect_uri: redirect_uri.into(),
            scope: scope.into_iter().collect(),
        };
        self.auth_flow = Some(auth_flow);
        self
    }

    /// Sets the authentication credentials of a specific user. May only be used by script apps.
    pub fn password_auth<T, U>(mut self, username: T, password: T, scope: U) -> Self
    where
        T: Into<String>,
        U: IntoIterator<Item = Scope>,
    {
        let auth_flow = AuthFlow::Password {
            password: password.into(),
            username: username.into(),
            scope: scope.into_iter().collect(),
        };
        self.auth_flow = Some(auth_flow);
        self
    }

    /// Sets the refresh token to authenticate with.
    ///
    /// If you already have a refresh token from a previous bearer token, Snoo can use it to
    /// retrieve a new token.
    pub fn refresh_token_auth<T>(mut self, refresh_token: T) -> Self
    where
        T: Into<String>,
    {
        let auth_flow = AuthFlow::RefreshToken(refresh_token.into());
        self.auth_flow = Some(auth_flow);
        self
    }

    /// Sets the [`Snoo`] client's `User-Agent` following the recommended format.
    ///
    /// [`Snoo`]: struct.Snoo.html
    ///
    /// Reddit uses the `User-Agent` header to identify the source of requests. Reddit requires that
    /// apps use a unique `User-Agent`. Reddit's recommended format is below.
    ///
    /// ```text
    /// User-Agent: android:com.example.reddit-app:v1.2.3 (by /u/rustacean)
    ///             └──┬──┘ └──────────┬─────────┘  └─┬─┘        └───┬───┘
    ///            platform         app_id         version        username
    /// ```
    pub fn user_agent(
        mut self,
        platform: &str,
        app_id: &str,
        version: &str,
        username: &str,
    ) -> Self {
        let user_agent = format!("{}:{}:{} (/u/{})", platform, app_id, version, username);
        self.user_agent = Some(user_agent);
        self
    }

    /// Sets the [`Snoo`] client's `User-Agent` following a custom format.
    ///
    /// [`Snoo`]: struct.Snoo.html
    ///
    /// Reddit uses the `User-Agent` header to identify the source of requests. Reddit requires that
    /// apps use a unique `User-Agent`. Reddit's recommended format is below.
    ///
    /// ```text
    /// User-Agent: android:com.example.reddit-app:v1.2.3 (by /u/rustacean)
    ///             └──┬──┘ └──────────┬─────────┘  └─┬─┘        └───┬───┘
    ///            platform         app_id         version        username
    /// ```
    pub fn custom_user_agent<T>(mut self, user_agent: T) -> Self
    where
        T: Into<String>,
    {
        self.user_agent = Some(user_agent.into());
        self
    }

    /// Attempts to build a `Snoo` client.
    pub fn build(self, handle: &Handle) -> Result<Snoo, SnooBuilderError> {
        let app_secrets = self.app_secrets
            .ok_or_else(|| SnooBuilderError::MissingAppSecrets)?;
        let user_agent = self.user_agent
            .ok_or_else(|| SnooBuilderError::MissingUserAgent)?;
        let http_client = HttpClient::new(handle, user_agent)?;
        let authenticator =
            Authenticator::new(app_secrets, self.auth_flow, self.bearer_token, &http_client)?;
        let reddit_client = RedditClient::new(authenticator, http_client);

        Ok(Snoo::new(reddit_client))
    }
}
